states_1 <- ancRECON(phy = phy,
data = MK_3state$data,
p = params,
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
head(states_1$lik.tip.states)
params2<-na.omit(c(MK_3state$solution))
params2
names(params2)<-na.omit(c(MK_3state$index.mat))
params2<-params2[order(as.numeric(names(params2)))]
params2
params2
#########
p=params
p
p[p == 0] = exp(-21)
p
rate=MK_3state$index.mat
c(p, 0)[rate]
c(p, 0)
Q[] <- c(p, 0)[rate]
Q
MK_3state$index.mat
Q=marix(nrow=6, ncol=6)
Q
Q=matrix(nrow=6, ncol=6)
Q
Q[] <- c(p, 0)[rate]
Q
diag(Q) <- -rowSums(Q)
Q
# # one way to get the parameters from your corHMM object in the correct order
params <- sapply(na.omit(c(MK_3state$index.mat)),
function(x) na.omit(c(MK_3state$solution))[x])
MK_3state$index.mat
MK_3state$solution
params
#########
p=params
rate=MK_3state$index.mat
p[p == 0] = exp(-21)
Q=matrix(nrow=6, ncol=6)
Q[] <- c(p, 0)[rate]
diag(Q) <- -rowSums(Q)
Q
#########
p=params2
rate=MK_3state$index.mat
p[p == 0] = exp(-21)
Q=matrix(nrow=6, ncol=6)
Q[] <- c(p, 0)[rate]
diag(Q) <- -rowSums(Q)
Q
rate
c(p, 0)
c(1:10)[rate]
c(p, 0)[rate]
Q[] <- c(p, 0)[rate]
Q[]
c(1:10)[rate]
rate
MK_3state$index.mat
MK_3state$solution
states_3 <- ancRECON(phy = phy,
data = MK_3state$data,
p = na.omit(c(MK_3state$solutio0n)),
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
states_3 <- ancRECON(phy = phy,
data = MK_3state$data,
p = na.omit(c(MK_3state$solutio0n)),
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
na.omit(c(MK_3state$solutio0n))
states_3 <- ancRECON(phy = phy,
data = MK_3state$data,
p = na.omit(c(MK_3state$solution)),
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
head(MK_3state$tip.states)
head(states_1$lik.tip.states)
head(states_2$lik.tip.states)
head(states_3$lik.tip.states)
na.omit(c(MK_3state$solution))
MK_3state$solution
params2<-na.omit(c(MK_3state$solutio0n))
names(params2)<-na.omit(c(MK_3state$index.mat))
params2<-params2[order(as.numeric(names(params2)))]
params2
states_2 <- ancRECON(phy = phy,
data = MK_3state$data,
p = unname(params2),
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
params2<-na.omit(c(MK_3state$solutio0n))
names(params2)<-na.omit(c(MK_3state$index.mat))
params2<-na.omit(c(MK_3state$solutio0n))
params2<-na.omit(c(MK_3state$solution))
names(params2)<-na.omit(c(MK_3state$index.mat))
params2<-params2[order(as.numeric(names(params2)))]
params2
states_2 <- ancRECON(phy = phy,
data = MK_3state$data,
p = unname(params2),
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
states_2 <- ancRECON(phy = phy,
data = MK_3state$data,
p = unname(params2),
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
params2
states_2 <- ancRECON(phy = phy,
data = MK_3state$data,
p = params2,
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
params2
states_3 <- ancRECON(phy = phy,
data = MK_3state$data,
p = na.omit(c(MK_3state$solution)),
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
head(MK_3state$tip.states)
head(states_1$lik.tip.states)
head(states_2$lik.tip.states)
head(states_3$lik.tip.states)
rate
Q
Q=matrix(nrow=6, ncol=6)
Q
c(p, 0)
p
c(1:14)[rate]
Q[]<-c(1:14)[rate]
Q
rate
c(1:14)[rate]
c(1:14)
rate
c(1:14)[rate]
# # one way to get the parameters from your corHMM object in the correct order
params <- sapply(na.omit(c(MK_3state$index.mat)),
function(x) na.omit(c(MK_3state$solution))[x])
MK_3state$index.mat
MK_3state$solution
params
#########
p=params
rate=MK_3state$index.mat
p[p == 0] = exp(-21)
Q=matrix(nrow=6, ncol=6)
Q[] <- c(p, 0)[rate]
Q
params
MK_3state <- corHMM(phy = phy,
data = data,
node.states="marginal",
rate.cat = 1,
get.tip.states=T)
# # one way to get the parameters from your corHMM object in the correct order
params <- sapply(na.omit(c(MK_3state$index.mat)),
function(x) na.omit(c(MK_3state$solution))[x])
MK_3state$index.mat
MK_3state$solution
params
primates
data
states_1 <- ancRECON(phy = phy,
data = MK_3state$data,
p = params,
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
head(MK_3state$tip.states)
head(states_1$lik.tip.states)
head(states_2$lik.tip.states)
data$T3<-sample(c(0,1), size=nrow(data))
data$T3<-sample(c(0,1), size=nrows(data))
data$T3<-sample(c(0,1), size=60, replace = T)
data
MK_3state <- corHMM(phy = phy,
data = data,
node.states="marginal",
rate.cat = 1,
get.tip.states=T)
params
# # one way to get the parameters from your corHMM object in the correct order
params <- sapply(na.omit(c(MK_3state$index.mat)),
function(x) na.omit(c(MK_3state$solution))[x])
MK_3state$index.mat
MK_3state$solution
params
states_1 <- ancRECON(phy = phy,
data = MK_3state$data,
p = params,
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
states_2 <- ancRECON(phy = phy,
data = MK_3state$data,
p = params2,
method = "marginal",
rate.cat = MK_3state$rate.cat,
ntraits = NULL,
rate.mat = MK_3state$index.mat,
root.p = MK_3state$root.p,
get.tip.states = TRUE)
head(MK_3state$tip.states)
head(states_1$lik.tip.states)
head(states_2$lik.tip.states)
setwd("~/Documents/amphibian_diversity_project/2021/corHMM/gymno/anc_states_marginal/")
library(ape)
library(geiger)
library(phytools)
library(corHMM)
library(tidyverse)
library(qgraph)
##############################################################################################
# load corHMM results
corHMM_fit<-readRDS("../corHMM_fit_gymno.rds")
fit_sum<-read_csv("../gymno_fit_summary.csv")
head(fit_sum)
# remove HMM2 models
fit_sum <- fit_sum %>%
filter(!str_detect(models, "HMM2"))
source("../../../data/_colour_schemes.R")
#############################################################################################
# check to see if ard and ard_HMM have ancestral states reconstructed
ard_fit<-corHMM_fit$ard
ard_hmm_fit<-corHMM_fit$HMM_ard
# check if ancestral states have been reconstructed (should have states)
ard_fit$states[1,]
ard_hmm_fit$states[1,]
ard_hmm_fit$tip.states
ard_hmm_fit$tip.states[1:5,]
best_hmm_fit<-ard_hmm_fit
na.omit(c(best_hmm_fit$solution))
best_hmm_fit$solution
best_hmm_fit_anc<-ancRECON(phy = best_hmm_fit$phy,
data = best_hmm_fit$data,
#p = best_hmm_fit_params,
p= na.omit(c(best_hmm_fit$solution)),
method = "marginal",
rate.cat = best_hmm_fit$rate.cat,
rate.mat = best_hmm_fit$index.mat,
root.p = best_hmm_fit$root.p)
best_hmm_fit$phy$node.label<-NA
best_hmm_fit_anc<-ancRECON(phy = best_hmm_fit$phy,
data = best_hmm_fit$data,
#p = best_hmm_fit_params,
p= na.omit(c(best_hmm_fit$solution)),
method = "marginal",
rate.cat = best_hmm_fit$rate.cat,
rate.mat = best_hmm_fit$index.mat,
root.p = best_hmm_fit$root.p)
best_hmm_fit_anc<-ancRECON(phy = best_hmm_fit$phy,
data = best_hmm_fit$data,
#p = best_hmm_fit_params,
p= na.omit(c(best_hmm_fit$solution)),
method = "marginal",
get.tip.states = T,
rate.cat = best_hmm_fit$rate.cat,
rate.mat = best_hmm_fit$index.mat,
root.p = best_hmm_fit$root.p)
head(ard_hmm_fit$tip.states)
head(best_hmm_fit_anc$lik.tip.states)
best_hmm_fit_params <- sapply(na.omit(c(best_hmm_fit$index.mat)),
function(x) na.omit(c(best_hmm_fit$solution))[x])
na.omit(c(best_hmm_fit$solution))
best_hmm_fit_params
best_hmm_fit_anc<-ancRECON(phy = best_hmm_fit$phy,
data = best_hmm_fit$data,
p = best_hmm_fit_params,
#p= na.omit(c(best_hmm_fit$solution)),
method = "marginal",
get.tip.states = T,
rate.cat = best_hmm_fit$rate.cat,
rate.mat = best_hmm_fit$index.mat,
root.p = best_hmm_fit$root.p)
head(best_hmm_fit_anc$lik.tip.states)
head(ard_hmm_fit$tip.states)
### reconstruct ancestral states for selected models
setwd("~/Documents/amphibian_diversity_project/2021/corHMM/caudata_sym_p0.0001/anc_states_joint/")
library(ape)
library(geiger)
library(phytools)
library(corHMM)
library(tidyverse)
library(qgraph)
##############################################################################################
# load corHMM results
corHMM_fit<-readRDS("../corHMM_fit_caudata.rds")
fit_sum<-read_csv("../caudata_fit_summary.csv")
head(fit_sum)
# remove HMM2 models
fit_sum <- fit_sum %>%
filter(!str_detect(models, "HMM2"))
#############################################################################################
# check to see if ard and ard_HMM have ancestral states reconstructed
ard_fit<-corHMM_fit$ard
ard_hmm_fit<-corHMM_fit$HMM_ard
# check if ancestral states have been reconstructed (should have states)
ard_fit$states[1,]
ard_hmm_fit$states[1,]
# extract best fitting model without hidden states (in this case it is ard_fit)
best_fit<-corHMM_fit[["terrestrial_v1_ard"]]
best_fit$states[1,]
# extract best fitting model wit hidden states
best_hmm_fit<-corHMM_fit[["HMM_terrestrial_v1_ard"]]
best_hmm_fit$states[1,]
best_fit$states[1,]
best_fit_params <- sapply(na.omit(c(best_fit$index.mat)),
function(x) na.omit(c(best_fit$solution))[x])
best_fit_anc<-ancRECON(phy = best_fit$phy,
data = best_fit$data,
p = best_fit_params,
method = "joint",
get.tip.states = TRUE,
rate.cat = best_fit$rate.cat,
rate.mat = best_fit$index.mat,
root.p = best_fit$root.p)
best_fit_anc$lik.tip.states
## add states to corHMM object
best_fit$states<-best_fit_anc$lik.anc.states
best_fit$data
best_fit$index.mat
### compare to if i ran corHMM earlier
best_fit_corHMM<-corHMM(phy=best_fit$phy,
data=best_fit$data,
rate.cat=best_fit$rate.cat,
rate.mat=best_fit$index.mat,
node.states="joint",
root.p=best_fit$root.p,
nstarts=10,
n.cores=4,
ip=0.0001)
best_fit_corHMM$tip.states
best_fit_corHMM$states
best_fit$states
best_fit_corHMM$states==best_fit$states
all(best_fit_corHMM$states==best_fit$states)
ard_hmm_fit_params <- sapply(na.omit(c(ard_hmm_fit$index.mat)),
function(x) na.omit(c(ard_hmm_fit$solution))[x])
best_hmm_fit_params <- sapply(na.omit(c(best_hmm_fit$index.mat)),
function(x) na.omit(c(best_hmm_fit$solution))[x])
best_hmm_fit_anc<-ancRECON(phy = best_hmm_fit$phy,
data = best_hmm_fit$data,
p = best_hmm_fit_params,
method = "joint",
get.tip.states = TRUE,
rate.cat = best_hmm_fit$rate.cat,
rate.mat = best_hmm_fit$index.mat,
root.p = best_hmm_fit$root.p)
best_hmm_fit_corHMM<-corHMM(phy=best_hmm_fit$phy,
data=best_hmm_fit$data,
rate.cat=best_hmm_fit$rate.cat,
rate.mat=best_hmm_fit$index.mat,
node.states="joint",
root.p=best_hmm_fit$root.p,
nstarts=10,
n.cores=4,
ip=0.0001)
## add states to corHMM object
best_hmm_fit$states<-best_hmm_fit_anc$lik.anc.states
best_hmm_fit$states
best_hmm_fit_corHMM$states
all(best_hmm_fit_corHMM$states==best_hmm_fit$states)
best_hmm_fit_corHMM$states
best_hmm_fit$states
### repeat with other parameterization
best_hmm_fit_anc2<-ancRECON(phy = best_hmm_fit$phy,
data = best_hmm_fit$data,
p = na.omit(c(best_hmm_fit$solution)),
method = "joint",
get.tip.states = TRUE,
rate.cat = best_hmm_fit$rate.cat,
rate.mat = best_hmm_fit$index.mat,
root.p = best_hmm_fit$root.p)
best_hmm_fit_anc2
best_hmm_fit_corHMM$states==best_hmm_fit_anc2$lik.anc.states
best_hmm_fit_corHMM$states==best_hmm_fit_anc2$lik.anc.states
plot(best_hmm_fit_corHMM$phy, show.tip.label=F, main="corhm")
par(mfrow=c(1,2))
par(mar=c(4,4,4,4))
plot(best_hmm_fit_corHMM$phy, show.tip.label=F, main="corhm")
best_hmm_fit_corHMM$data$rep_mode)
best_hmm_fit_corHMM$data$rep_mode
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit_corHMM$data$rep_mode)],cex=0.5)
source("~/My Cloud/my_r_functions/find_transitions.R")
source("~/Documents/amphibian_diversity_project/2021/data/_colour_schemes.R")
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit_corHMM$data$rep_mode)],cex=0.5)
best_hmm_fit_corHMM$states
best_hmm_fit_corHMM$states
rep.cols1[best_hmm_fit_corHMM$states]
rep.cols1
rep_cols<-rep(rep.cols1[c("A","D","P","S","V")],2)
rep_cols
rep_cols[c(1,2,3,3)]
best_hmm_fit_corHMM$states
nodelabels(pie=best_hmm_fit_corHMM$states, piecol= rep_cols[best_hmm_fit_corHMM$states], cex = 0.5)
best_hmm_fit_corHMM$states
nodelabels(pch=19, col=rep_cols[best_hmm_fit_corHMM$states])
nodelabels(pch=19, col=rep_cols[best_hmm_fit_corHMM$states], cex=0.5)
plot(best_hmm_fit_corHMM$phy, show.tip.label=F, main="corhm")
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit_corHMM$data$rep_mode)],cex=0.5)
nodelabels(pch=19, col=rep_cols[best_hmm_fit_corHMM$states], cex=0.5)
plot(best_hmm_fit$phy, show.tip.label=F, main="anc")
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit$data$rep_mode)],cex=0.5)
nodelabels(pch=19, col=rep_cols[best_hmm_fit$states], cex=0.5)
par(mfrow=c(1,2))
par(mar=c(4,4,4,4))
plot(best_hmm_fit_corHMM$phy, show.tip.label=F, main="corhm")
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit_corHMM$data$rep_mode)],cex=0.5)
nodelabels(pch=19, col=rep_cols[best_hmm_fit_corHMM$states], cex=0.5)
plot(best_hmm_fit$phy, show.tip.label=F, main="anc")
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit$data$rep_mode)],cex=0.5)
nodelabels(pch=19, col=rep_cols[best_hmm_fit$states], cex=0.5)
par(mfrow=c(1,2))
par(mar=c(1,1,3,1))
plot(best_hmm_fit_corHMM$phy, show.tip.label=F, main="corhm")
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit_corHMM$data$rep_mode)],cex=0.5)
nodelabels(pch=19, col=rep_cols[best_hmm_fit_corHMM$states], cex=0.5)
plot(best_hmm_fit$phy, show.tip.label=F, main="anc")
tiplabels(pch=15, col=rep.cols1[as.character(best_hmm_fit$data$rep_mode)],cex=0.5)
nodelabels(pch=19, col=rep_cols[best_hmm_fit$states], cex=0.5)
# loading package example
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
# run corHMM() with two rate categories and set to estimate both tip and node states
MK_3state <- corHMM(phy = phy,
data = data,
node.states="marginal",
rate.cat = 2,
get.tip.states=T)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
# run corHMM() with two rate categories and set to estimate both tip and node states
MK_3state <- corHMM(phy = phy,
data = data,
node.states="marginal",
rate.cat = 2,
get.tip.states=T)
# loading package example
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
# run corHMM() with two rate categories and set to estimate both tip and node states
MK_3state <- corHMM(phy = phy,
data = data,
node.states="marginal",
rate.cat = 2,
get.tip.states=T)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
# run corHMM() with two rate categories and set to estimate both tip and node states
MK_3state <- corHMM(phy = phy,
data = data,
rate.cat = 2,
node.states="marginal",
get.tip.states=T)
# run corHMM() with two rate categories and set to estimate both tip and node states
MK_3state <- corHMM(phy = phy,
data = data,
rate.cat = 2)
